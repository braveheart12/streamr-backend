package com.unifina.signalpath.blockchain

import com.google.gson.Gson
import com.unifina.ModuleTestingSpecification
import com.unifina.data.FeedEvent
import com.unifina.datasource.DataSource
import com.unifina.domain.security.IntegrationKey
import com.unifina.domain.security.SecUser
import com.unifina.domain.signalpath.Canvas
import com.unifina.domain.signalpath.Module
import com.unifina.service.EthereumIntegrationKeyService
import com.unifina.signalpath.SignalPath
import com.unifina.utils.Globals
import com.unifina.utils.testutils.ModuleTestHelper
import grails.converters.JSON
import grails.test.mixin.Mock
import org.web3j.abi.FunctionEncoder
import org.web3j.abi.TypeEncoder
import org.web3j.abi.datatypes.DynamicArray
import org.web3j.abi.datatypes.Type
import org.web3j.abi.datatypes.Uint
import org.web3j.protocol.Web3j
import org.web3j.protocol.core.DefaultBlockParameter
import org.web3j.protocol.core.DefaultBlockParameterName
import org.web3j.protocol.core.Request
import org.web3j.protocol.core.methods.request.Transaction
import org.web3j.protocol.core.methods.response.EthCall
import org.web3j.protocol.core.methods.response.EthGetTransactionCount
import org.web3j.protocol.core.methods.response.EthGetTransactionReceipt
import org.web3j.protocol.core.methods.response.EthSendTransaction
import org.web3j.protocol.core.methods.response.TransactionReceipt
import spock.lang.Specification

import java.util.concurrent.CompletableFuture
import java.util.concurrent.CompletionStage
import java.util.function.Consumer

@Mock([Canvas, Module,IntegrationKey, SecUser])
class SendEthereumTransactionSpec extends ModuleTestingSpecification {
	public static final String TXHASH = "0x123";
	public static final int CONSTANT_CALL_ARRAY_CONTENT = 13;


	SendEthereumTransaction module

	String getFnResponse(){
		//encode a uint[] response containing CONSTANT_CALL_ARRAY_CONTENT
		DynamicArray array = new DynamicArray<Uint>(new Uint(CONSTANT_CALL_ARRAY_CONTENT));
		//encodeConstructor can also be used to encode function output
		String enc = FunctionEncoder.encodeConstructor([array])
		return enc;
	}

	def setup() {
		// mock the key for ethereum account
		SecUser user = new SecUser(name: "name", username: "name@name.com", password: "pass").save(failOnError: true, validate: false)
		IntegrationKey key = new IntegrationKey(service: IntegrationKey.Service.ETHEREUM, name: "test key", json: '{"privateKey":"0x5e98cce00cff5dea6b454889f359a4ec06b9fa6b88e9d69b86de8e1c81887da0","address":"0x1234"}', user: user, idInService: "0x1234")
		key.id = "sgKjr1eHQpqTmwz3vK3DqwUK1wFlrfRJa9mnf_xTeFJQ"
		key.save(failOnError: true, validate: true)
		mockBean(EthereumIntegrationKeyService.class, Stub(EthereumIntegrationKeyService) {
			getAllKeysForUser(user) >> [key];
			decryptPrivateKey(_) >> {k ->
				Map json = JSON.parse(k[0].json)
				return (String) json.privateKey;
			}
		})


		module = new SendEthereumTransaction() {
			@Override
			Web3j getWeb3j() {
				return mockWeb3j;
			}
			@Override
			public void setDomainObject(Module domainObject) {}
			/*
			@Override
			Module getDomainObject(){
				return new Module();
			}
			*/
		}
//		module.globals = mockGlobals([:], user)
		module.globals = mockGlobals
		module.init()
		module.configure(applyConfig)
		def signalPath = new SignalPath(true)
		signalPath.setCanvas(new Canvas())
		module.setParentSignalPath(signalPath)
	}

	/** Mocked event queue. Works manually in tests, please call module.receive(queuedEvent) */
	def mockGlobals = Stub(Globals) {
		getDataSource() >> Stub(DataSource) {
			enqueueEvent(_) >> { feedEvent ->
				functionCallResult = feedEvent[0]
			}
		}
		isRealtime() >> true
	}

	// temporary storage for async transaction generated by AbstractHttpModule, passing from globals to mockClient
	FeedEvent functionCallResult
/*
				EthCall response = web3j.ethCall(
					Transaction.createEthCallTransaction(ethereumAccount.getAddress(), c.getAddress(), encodeFnCall),
					DefaultBlockParameterName.LATEST).sendAsync().get();
 */
	def logList = []
	def mockWeb3j = Stub(Web3j) {
		ethCall(_,_) >> { Transaction tx2, DefaultBlockParameterName latest ->
			return new Request(){
				public EthCall send() throws IOException {
					return new EthCall(){
						@Override
						public String getValue(){
							return getFnResponse();
						}
					};
				}
				public CompletableFuture sendAsync() {
					return new CompletableFuture(){
						@Override
						CompletableFuture thenAccept(Consumer<? super EthSendTransaction> consumer){
							EthSendTransaction tx = new EthSendTransaction() {
								@Override
								public String getTransactionHash() {
									return TXHASH;
								}

								@Override
								public String getRawResponse() {
									return RAW_FNCALL_RESPONSE;
								}
							}
							consumer.accept(tx);
						}
					}
				}
			};
		}

		ethGetTransactionReceipt(_) >> Stub(Request) {
			send() >> Stub(EthGetTransactionReceipt) {
				getResult() >> Stub(TransactionReceipt) {
					getLogs() >> logList
				}
			}
		}

		ethGetTransactionCount(_, _) >> { String address, DefaultBlockParameterName latest ->
			return new Request(){
				public EthGetTransactionCount send() throws IOException {
					return new EthGetTransactionCount(){
						@Override
						public BigInteger getTransactionCount(){
							return 1;
						}
					};
				}
			};
		}
		ethSendRawTransaction(_) >> { String bytesHex ->
			return new Request(){
				public EthSendTransaction send() throws IOException {
					return new EthSendTransaction(){
						@Override
						public String getTransactionHash(){
							return TXHASH;
						}
					};
				}
				public CompletableFuture sendAsync() {
					return new CompletableFuture(){
						@Override
						CompletableFuture thenAccept(Consumer<? super EthSendTransaction> consumer){
							EthSendTransaction tx = new EthSendTransaction() {
								@Override
								public String getTransactionHash() {
									return TXHASH;
								}

								@Override
								public String getRawResponse() {
									return RAW_FNCALL_RESPONSE;
								}
							}
							consumer.accept(tx);
						}
					}
				}
			};
		}
		/*
		ethGetTransactionReceipt(_) >> { String txHash ->
			return new Request(){
				public EthGetTransactionReceipt send() throws IOException {
					return new EthGetTransactionReceipt(){
						@Override
						public TransactionReceipt getResult(){
							return new TransactionReceipt() {
								@Override
								public String getContractAddress() {
									return DEPLOY_ADDRESS;
								}
							}
						}
					};
				}

			}

		}
		ethSendRawTransaction(_) >> Stub(Request) {
			sendAsync() >> {
				thenAccept(_) >> { consumer ->
					EthSendTransaction tx
					consumer.accept(tx)
				}
			}
		}
		*/

		// helpers for handy mocking of different responses within same test
		def responseI = [].iterator()
		/*
		{
					def ret = response
					// array => iterate
					if (ret instanceof Iterable) {
						// end of array -> restart from beginning
						if (!responseI.hasNext()) {
							responseI = response.iterator()
						}
						ret = responseI.hasNext() ? responseI.next() : []
					}
					// closure => execute
					if (ret instanceof Closure) {
						ret = ret(request)
					}
					// convert into JSON if not String
					ret = ret instanceof String ? ret : new JsonBuilder(ret).toString()
					return new StringEntity(ret)
				}
		 */
	}

	static Map applyConfig = new Gson().fromJson('''
{
  "outputs": [
    {
      "connected": true,
      "name": "errors",
      "canConnect": true,
      "id": "ep_P3GiGglLSYalVojWpyvG3Q",
      "type": "List",
      "export": false,
      "longName": "EthereumSend.errors"
    },
    {
      "connected": true,
      "name": "out",
      "canConnect": true,
      "id": "ep__t9VKixtTMaF-1te8c5Byw",
      "type": "List",
      "export": false,
      "longName": "EthereumSend.out"
    }
  ],
  "layout": {
    "position": {
      "top": "105px",
      "left": "436px"
    }
  },
  "inputs": [
    {
      "sourceId": "ep_2Y1qp6qnS1y7hvrObQGPAg",
      "canToggleDrivingInput": false,
      "drivingInput": false,
      "type": "EthereumContract",
      "connected": true,
      "requiresConnection": true,
      "name": "contract",
      "canConnect": true,
      "id": "ep_nxUlNHzjRKOwGNWg-px1UQ",
      "jsClass": "EthereumContractInput",
      "acceptedTypes": [
        "EthereumContract"
      ],
      "export": false,
      "value": {
        "address": "0x338090c5492c5c5e41a4458f5fc4b205cbc54a24",
        "abi": [
          {
            "outputs": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "constant": true,
            "payable": false,
            "inputs": [
              {
                "name": "a",
                "type": "uint256"
              }
            ],
            "name": "testOutput",
            "stateMutability": "view",
            "type": "function"
          },
          {
            "outputs": [
              {
                "name": "out",
                "type": "uint256[]"
              }
            ],
            "constant": true,
            "payable": false,
            "inputs": [
              {
                "name": "a",
                "type": "uint256"
              }
            ],
            "name": "testOutput1D",
            "stateMutability": "view",
            "type": "function"
          },
          {
            "inputs": [
              {
                "indexed": false,
                "name": "poster",
                "type": "address"
              },
              {
                "indexed": false,
                "name": "data",
                "type": "string"
              }
            ],
            "name": "testEvent",
            "anonymous": false,
            "type": "event"
          }
        ]
      },
      "longName": "EthereumSend.contract"
    },
    {
      "sourceId": "ep_2jaahlX3Ty6AeQQIbsV4XA",
      "canToggleDrivingInput": true,
      "drivingInput": true,
      "type": "Double",
      "connected": true,
      "requiresConnection": true,
      "name": "a",
      "canConnect": true,
      "id": "ep_YJHJEL4pRUqLusUtyQdLlA",
      "acceptedTypes": [
        "Double"
      ],
      "canHaveInitialValue": true,
      "export": false,
      "initialValue": 123,
      "longName": "EthereumSend.a"
    }
  ],
  "name": "EthereumSend",
  "options": {
    "gasPriceGWei": {
      "type": "double",
      "value": 20
    },
    "activateInHistoricalMode": {
      "type": "boolean",
      "value": false
    },
    "network": {
      "possibleValues": [
        {
          "text": "ropsten",
          "value": "ropsten"
        },
        {
          "text": "rinkeby",
          "value": "rinkeby"
        }
      ],
      "type": "string",
      "value": "rinkeby"
    }
  },
  "canRefresh": false,
  "id": 1150,
  "params": [
    {
      "possibleValues": [
        {
          "name": "(none)",
          "value": {}
        },
        {
          "name": "t0",
          "value": "UGEaxuOqRBeqVFQNws8-6gRg8MeV9xRUmNtIDWuYp1qQ"
        }
      ],
      "canToggleDrivingInput": true,
      "defaultValue": {},
      "drivingInput": false,
      "type": "String",
      "connected": false,
      "requiresConnection": false,
      "name": "ethAccount",
      "canConnect": false,
      "id": "ep_jToBE5S4Qg-V6G_WbIrDdQ",
      "acceptedTypes": [
        "String"
      ],
      "export": false,
      "value": "UGEaxuOqRBeqVFQNws8-6gRg8MeV9xRUmNtIDWuYp1qQ",
      "longName": "EthereumSend.ethAccount"
    },
    {
      "possibleValues": [
        {
          "name": "testOutput",
          "value": "testOutput"
        },
        {
          "name": "testOutput1D",
          "value": "testOutput1D"
        }
      ],
      "canToggleDrivingInput": true,
      "defaultValue": "",
      "drivingInput": false,
      "type": "String",
      "connected": false,
      "updateOnChange": true,
      "requiresConnection": false,
      "name": "function",
      "isTextArea": false,
      "canConnect": true,
      "id": "ep_81s3PcBETUawfxcvt1DhMQ",
      "acceptedTypes": [
        "String"
      ],
      "export": false,
      "value": "testOutput1D",
      "longName": "EthereumSend.function"
    }
  ],
  "jsModule": "GenericModule",
  "type": "module",
  "canClearState": true,
  "hash": 3
}
''', Map.class)

	void "test"() {
		logList = []
		def inputs = [trigger: true]
		def outputs = [errors: []]
		module.activateWithSideEffects()
		module.receive(functionCallResult)
		def rslt = module.getOutput("out").getValue();
		expect:
		rslt instanceof List
		rslt[0] == CONSTANT_CALL_ARRAY_CONTENT.toString()
	}

}
